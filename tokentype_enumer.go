// Code generated by "enumer -type=TokenType -json"; DO NOT EDIT.

package sqltoken

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _TokenTypeName = "CommentWhitespaceQuestionMarkAtSignDollarNumberColonWordLiteralIdentifierAtWordNumberSemicolonPunctuationWordOtherDelimiter"

var _TokenTypeIndex = [...]uint8{0, 7, 17, 29, 35, 47, 56, 63, 73, 79, 85, 94, 105, 109, 114, 123}

const _TokenTypeLowerName = "commentwhitespacequestionmarkatsigndollarnumbercolonwordliteralidentifieratwordnumbersemicolonpunctuationwordotherdelimiter"

func (i TokenType) String() string {
	if i < 0 || i >= TokenType(len(_TokenTypeIndex)-1) {
		return fmt.Sprintf("TokenType(%d)", i)
	}
	return _TokenTypeName[_TokenTypeIndex[i]:_TokenTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TokenTypeNoOp() {
	var x [1]struct{}
	_ = x[Comment-(0)]
	_ = x[Whitespace-(1)]
	_ = x[QuestionMark-(2)]
	_ = x[AtSign-(3)]
	_ = x[DollarNumber-(4)]
	_ = x[ColonWord-(5)]
	_ = x[Literal-(6)]
	_ = x[Identifier-(7)]
	_ = x[AtWord-(8)]
	_ = x[Number-(9)]
	_ = x[Semicolon-(10)]
	_ = x[Punctuation-(11)]
	_ = x[Word-(12)]
	_ = x[Other-(13)]
	_ = x[Delimiter-(14)]
}

var _TokenTypeValues = []TokenType{Comment, Whitespace, QuestionMark, AtSign, DollarNumber, ColonWord, Literal, Identifier, AtWord, Number, Semicolon, Punctuation, Word, Other, Delimiter}

var _TokenTypeNameToValueMap = map[string]TokenType{
	_TokenTypeName[0:7]:          Comment,
	_TokenTypeLowerName[0:7]:     Comment,
	_TokenTypeName[7:17]:         Whitespace,
	_TokenTypeLowerName[7:17]:    Whitespace,
	_TokenTypeName[17:29]:        QuestionMark,
	_TokenTypeLowerName[17:29]:   QuestionMark,
	_TokenTypeName[29:35]:        AtSign,
	_TokenTypeLowerName[29:35]:   AtSign,
	_TokenTypeName[35:47]:        DollarNumber,
	_TokenTypeLowerName[35:47]:   DollarNumber,
	_TokenTypeName[47:56]:        ColonWord,
	_TokenTypeLowerName[47:56]:   ColonWord,
	_TokenTypeName[56:63]:        Literal,
	_TokenTypeLowerName[56:63]:   Literal,
	_TokenTypeName[63:73]:        Identifier,
	_TokenTypeLowerName[63:73]:   Identifier,
	_TokenTypeName[73:79]:        AtWord,
	_TokenTypeLowerName[73:79]:   AtWord,
	_TokenTypeName[79:85]:        Number,
	_TokenTypeLowerName[79:85]:   Number,
	_TokenTypeName[85:94]:        Semicolon,
	_TokenTypeLowerName[85:94]:   Semicolon,
	_TokenTypeName[94:105]:       Punctuation,
	_TokenTypeLowerName[94:105]:  Punctuation,
	_TokenTypeName[105:109]:      Word,
	_TokenTypeLowerName[105:109]: Word,
	_TokenTypeName[109:114]:      Other,
	_TokenTypeLowerName[109:114]: Other,
	_TokenTypeName[114:123]:      Delimiter,
	_TokenTypeLowerName[114:123]: Delimiter,
}

var _TokenTypeNames = []string{
	_TokenTypeName[0:7],
	_TokenTypeName[7:17],
	_TokenTypeName[17:29],
	_TokenTypeName[29:35],
	_TokenTypeName[35:47],
	_TokenTypeName[47:56],
	_TokenTypeName[56:63],
	_TokenTypeName[63:73],
	_TokenTypeName[73:79],
	_TokenTypeName[79:85],
	_TokenTypeName[85:94],
	_TokenTypeName[94:105],
	_TokenTypeName[105:109],
	_TokenTypeName[109:114],
	_TokenTypeName[114:123],
}

// TokenTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TokenTypeString(s string) (TokenType, error) {
	if val, ok := _TokenTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TokenTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to TokenType values", s)
}

// TokenTypeValues returns all values of the enum
func TokenTypeValues() []TokenType {
	return _TokenTypeValues
}

// TokenTypeStrings returns a slice of all String values of the enum
func TokenTypeStrings() []string {
	strs := make([]string, len(_TokenTypeNames))
	copy(strs, _TokenTypeNames)
	return strs
}

// IsATokenType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i TokenType) IsATokenType() bool {
	for _, v := range _TokenTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for TokenType
func (i TokenType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for TokenType
func (i *TokenType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("TokenType should be a string, got %s", data)
	}

	var err error
	*i, err = TokenTypeString(s)
	return err
}
